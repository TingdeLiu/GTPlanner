"""
è§„åˆ’ç»“æžœå¯¼å‡ºå·¥å…·

ç”¨äºŽå°† GTPlanner çš„å¯¹è¯åŽ†å²å’Œè§„åˆ’ç»“æžœå¯¼å‡ºä¸ºç»“æž„åŒ–çš„ Markdown æ–‡ä»¶ã€‚
æ”¯æŒå¤šè¯­è¨€è¾“å‡ºå’Œè‡ªå®šä¹‰æ¨¡æ¿ã€‚
"""

import os
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any
from ..context_types import Message, MessageRole
from ..persistence.sqlite_session_manager import SQLiteSessionManager
from ..persistence.database_dao import DatabaseDAO


class PlannerExporter:
    """è§„åˆ’ç»“æžœå¯¼å‡ºå™¨"""

    # Markdown æ¨¡æ¿ - å¤šè¯­è¨€æ”¯æŒ
    TEMPLATES = {
        "zh": {
            "title": "# {title}\n\n",
            "metadata": "**åˆ›å»ºæ—¶é—´**: {created_at}  \n**ä¼šè¯ID**: {session_id}  \n**é¡¹ç›®é˜¶æ®µ**: {project_stage}  \n**æ¶ˆæ¯æ•°é‡**: {message_count}  \n\n---\n\n",
            "section_requirement": "## ðŸ“‹ éœ€æ±‚æè¿°\n\n",
            "section_planning": "## ðŸŽ¯ è§„åˆ’æ–¹æ¡ˆ\n\n",
            "section_conversation": "## ðŸ’¬ å®Œæ•´å¯¹è¯è®°å½•\n\n",
            "user_message": "### ðŸ‘¤ ç”¨æˆ·\n\n{content}\n\n",
            "assistant_message": "### ðŸ¤– åŠ©æ‰‹\n\n{content}\n\n",
            "tool_message": "### ðŸ”§ å·¥å…·æ‰§è¡Œ: {tool_name}\n\n```json\n{content}\n```\n\n",
            "footer": "\n---\n\n*æ­¤æ–‡æ¡£ç”± GTPlanner è‡ªåŠ¨ç”ŸæˆäºŽ {export_time}*\n",
            "no_planning": "*æš‚æ— æ˜Žç¡®çš„è§„åˆ’å†…å®¹*"
        },
        "en": {
            "title": "# {title}\n\n",
            "metadata": "**Created**: {created_at}  \n**Session ID**: {session_id}  \n**Project Stage**: {project_stage}  \n**Messages**: {message_count}  \n\n---\n\n",
            "section_requirement": "## ðŸ“‹ Requirements\n\n",
            "section_planning": "## ðŸŽ¯ Planning\n\n",
            "section_conversation": "## ðŸ’¬ Conversation History\n\n",
            "user_message": "### ðŸ‘¤ User\n\n{content}\n\n",
            "assistant_message": "### ðŸ¤– Assistant\n\n{content}\n\n",
            "tool_message": "### ðŸ”§ Tool Execution: {tool_name}\n\n```json\n{content}\n```\n\n",
            "footer": "\n---\n\n*Generated by GTPlanner at {export_time}*\n",
            "no_planning": "*No explicit planning content found*"
        },
        "ja": {
            "title": "# {title}\n\n",
            "metadata": "**ä½œæˆæ—¥æ™‚**: {created_at}  \n**ã‚»ãƒƒã‚·ãƒ§ãƒ³ID**: {session_id}  \n**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ®µéšŽ**: {project_stage}  \n**ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°**: {message_count}  \n\n---\n\n",
            "section_requirement": "## ðŸ“‹ è¦ä»¶èª¬æ˜Ž\n\n",
            "section_planning": "## ðŸŽ¯ è¨ˆç”»æ¡ˆ\n\n",
            "section_conversation": "## ðŸ’¬ ä¼šè©±å±¥æ­´\n\n",
            "user_message": "### ðŸ‘¤ ãƒ¦ãƒ¼ã‚¶ãƒ¼\n\n{content}\n\n",
            "assistant_message": "### ðŸ¤– ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ\n\n{content}\n\n",
            "tool_message": "### ðŸ”§ ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œ: {tool_name}\n\n```json\n{content}\n```\n\n",
            "footer": "\n---\n\n*ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ {export_time} ã« GTPlanner ã«ã‚ˆã£ã¦è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸ*\n",
            "no_planning": "*æ˜Žç¢ºãªè¨ˆç”»å†…å®¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ*"
        },
        "es": {
            "title": "# {title}\n\n",
            "metadata": "**Creado**: {created_at}  \n**ID de SesiÃ³n**: {session_id}  \n**Etapa del Proyecto**: {project_stage}  \n**Mensajes**: {message_count}  \n\n---\n\n",
            "section_requirement": "## ðŸ“‹ Requisitos\n\n",
            "section_planning": "## ðŸŽ¯ PlanificaciÃ³n\n\n",
            "section_conversation": "## ðŸ’¬ Historial de ConversaciÃ³n\n\n",
            "user_message": "### ðŸ‘¤ Usuario\n\n{content}\n\n",
            "assistant_message": "### ðŸ¤– Asistente\n\n{content}\n\n",
            "tool_message": "### ðŸ”§ EjecuciÃ³n de Herramienta: {tool_name}\n\n```json\n{content}\n```\n\n",
            "footer": "\n---\n\n*Generado por GTPlanner el {export_time}*\n",
            "no_planning": "*No se encontrÃ³ contenido de planificaciÃ³n explÃ­cito*"
        },
        "fr": {
            "title": "# {title}\n\n",
            "metadata": "**CrÃ©Ã©**: {created_at}  \n**ID de Session**: {session_id}  \n**Ã‰tape du Projet**: {project_stage}  \n**Messages**: {message_count}  \n\n---\n\n",
            "section_requirement": "## ðŸ“‹ Exigences\n\n",
            "section_planning": "## ðŸŽ¯ Planification\n\n",
            "section_conversation": "## ðŸ’¬ Historique de Conversation\n\n",
            "user_message": "### ðŸ‘¤ Utilisateur\n\n{content}\n\n",
            "assistant_message": "### ðŸ¤– Assistant\n\n{content}\n\n",
            "tool_message": "### ðŸ”§ ExÃ©cution d'Outil: {tool_name}\n\n```json\n{content}\n```\n\n",
            "footer": "\n---\n\n*GÃ©nÃ©rÃ© par GTPlanner le {export_time}*\n",
            "no_planning": "*Aucun contenu de planification explicite trouvÃ©*"
        }
    }

    def __init__(self, session_manager: Optional[SQLiteSessionManager] = None, language: str = "zh"):
        """
        åˆå§‹åŒ–å¯¼å‡ºå™¨

        Args:
            session_manager: ä¼šè¯ç®¡ç†å™¨å®žä¾‹ï¼Œå¦‚æžœä¸ºNoneåˆ™åˆ›å»ºæ–°å®žä¾‹
            language: è¾“å‡ºè¯­è¨€ (zh/en/ja/es/fr)
        """
        self.session_manager = session_manager or SQLiteSessionManager()
        self.dao = DatabaseDAO()
        self.language = language if language in self.TEMPLATES else "zh"

    def _get_template(self, key: str) -> str:
        """èŽ·å–æ¨¡æ¿å­—ç¬¦ä¸²"""
        return self.TEMPLATES[self.language].get(key, "")

    def _extract_planning_content(self, messages: List[Message]) -> str:
        """
        ä»Žå¯¹è¯åŽ†å²ä¸­æå–è§„åˆ’ç›¸å…³å†…å®¹

        Args:
            messages: æ¶ˆæ¯åˆ—è¡¨

        Returns:
            æå–çš„è§„åˆ’å†…å®¹
        """
        planning_parts = []

        for msg in messages:
            # æå–åŠ©æ‰‹çš„è§„åˆ’å›žå¤
            if msg.role == MessageRole.ASSISTANT and msg.content:
                # æ£€æŸ¥æ˜¯å¦åŒ…å«è§„åˆ’å…³é”®è¯
                if any(keyword in msg.content.lower() for keyword in
                       ['è§„åˆ’', 'æ–¹æ¡ˆ', 'è®¾è®¡', 'plan', 'design', 'architecture', 'æµç¨‹', 'workflow']):
                    planning_parts.append(msg.content)

        return "\n\n".join(planning_parts) if planning_parts else self._get_no_planning_message()

    def _get_no_planning_message(self) -> str:
        """èŽ·å–æ— è§„åˆ’å†…å®¹æç¤º"""
        return self._get_template("no_planning")

    def _format_message(self, msg: Message) -> str:
        """
        æ ¼å¼åŒ–å•æ¡æ¶ˆæ¯

        Args:
            msg: æ¶ˆæ¯å¯¹è±¡

        Returns:
            æ ¼å¼åŒ–åŽçš„ Markdown å­—ç¬¦ä¸²
        """
        if msg.role == MessageRole.USER:
            return self._get_template("user_message").format(content=msg.content)
        elif msg.role == MessageRole.ASSISTANT:
            return self._get_template("assistant_message").format(content=msg.content)
        elif msg.role == MessageRole.TOOL:
            # å°è¯•æå–å·¥å…·åç§°
            tool_name = "Unknown"
            content = msg.content

            # å¦‚æžœå†…å®¹æ˜¯å­—å…¸æ ¼å¼ï¼Œå°è¯•æå–å·¥å…·åç§°
            if isinstance(msg.content, str) and msg.content.startswith("{"):
                import json
                try:
                    data = json.loads(msg.content)
                    tool_name = data.get("tool_name", tool_name)
                    content = json.dumps(data, indent=2, ensure_ascii=False)
                except:
                    pass

            return self._get_template("tool_message").format(
                tool_name=tool_name,
                content=content
            )
        else:
            return f"**{msg.role.value}**: {msg.content}\n\n"

    def export_session_to_markdown(
        self,
        session_id: Optional[str] = None,
        output_path: Optional[str] = None,
        include_conversation: bool = True,
        auto_filename: bool = True
    ) -> str:
        """
        å¯¼å‡ºä¼šè¯åˆ° Markdown æ–‡ä»¶

        Args:
            session_id: ä¼šè¯IDï¼Œå¦‚æžœä¸ºNoneåˆ™ä½¿ç”¨å½“å‰ä¼šè¯
            output_path: è¾“å‡ºæ–‡ä»¶è·¯å¾„ï¼Œå¦‚æžœä¸ºNoneåˆ™ä½¿ç”¨è‡ªåŠ¨ç”Ÿæˆçš„è·¯å¾„
            include_conversation: æ˜¯å¦åŒ…å«å®Œæ•´å¯¹è¯åŽ†å²
            auto_filename: æ˜¯å¦è‡ªåŠ¨ç”Ÿæˆæ–‡ä»¶åï¼ˆå·²åºŸå¼ƒï¼Œç”±output_pathæ˜¯å¦ä¸ºNoneå†³å®šï¼‰

        Returns:
            å¯¼å‡ºçš„æ–‡ä»¶è·¯å¾„

        Raises:
            ValueError: å½“æ²¡æœ‰å¯ç”¨çš„ä¼šè¯æ—¶
        """
        # ç¡®å®šä¼šè¯ID
        if session_id is None:
            session_id = self.session_manager.current_session_id
            if not session_id:
                raise ValueError("No active session. Please specify a session_id or create a new session.")

        # èŽ·å–ä¼šè¯ä¿¡æ¯
        session_info = self.dao.get_session(session_id)
        if not session_info:
            raise ValueError(f"Session not found: {session_id}")

        # èŽ·å–å¯¹è¯åŽ†å²
        context = self.session_manager.build_agent_context(session_id)
        if not context:
            raise ValueError(f"Failed to build context for session: {session_id}")

        # æž„å»º Markdown å†…å®¹
        md_content = self._build_markdown_content(
            session_info=session_info,
            messages=context.dialogue_history,
            include_conversation=include_conversation
        )

        # ç¡®å®šè¾“å‡ºè·¯å¾„
        # å¦‚æžœç”¨æˆ·æ²¡æœ‰æä¾›è·¯å¾„ï¼Œä½¿ç”¨é»˜è®¤æ–‡ä»¶å Plan.mdï¼ˆä¿å­˜åˆ°å½“å‰è·¯å¾„ï¼‰
        if output_path is None:
            output_path = "Plan.md"
        # ç”¨æˆ·æä¾›äº†è·¯å¾„ï¼Œç›´æŽ¥ä½¿ç”¨ï¼ˆç›¸å¯¹è·¯å¾„æˆ–ç»å¯¹è·¯å¾„ï¼‰

        # ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
        output_dir = os.path.dirname(output_path)
        if output_dir:
            os.makedirs(output_dir, exist_ok=True)

        # å†™å…¥æ–‡ä»¶
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(md_content)

        return output_path

    def _build_markdown_content(
        self,
        session_info: Dict[str, Any],
        messages: List[Message],
        include_conversation: bool
    ) -> str:
        """
        æž„å»º Markdown å†…å®¹

        Args:
            session_info: ä¼šè¯ä¿¡æ¯
            messages: æ¶ˆæ¯åˆ—è¡¨
            include_conversation: æ˜¯å¦åŒ…å«å®Œæ•´å¯¹è¯

        Returns:
            å®Œæ•´çš„ Markdown å†…å®¹
        """
        parts = []

        # æ ‡é¢˜
        title = session_info.get("title", "Untitled Planning")
        parts.append(self._get_template("title").format(title=title))

        # å…ƒæ•°æ®
        parts.append(self._get_template("metadata").format(
            created_at=session_info.get("created_at", "Unknown"),
            session_id=session_info.get("session_id", "Unknown")[:12] + "...",
            project_stage=session_info.get("project_stage", "Unknown"),
            message_count=len(messages)
        ))

        # éœ€æ±‚æè¿°ï¼ˆç¬¬ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯ï¼‰
        user_messages = [msg for msg in messages if msg.role == MessageRole.USER]
        if user_messages:
            parts.append(self._get_template("section_requirement"))
            parts.append(user_messages[0].content + "\n\n")

        # è§„åˆ’æ–¹æ¡ˆï¼ˆæå–çš„è§„åˆ’å†…å®¹ï¼‰
        parts.append(self._get_template("section_planning"))
        planning_content = self._extract_planning_content(messages)
        parts.append(planning_content + "\n\n")

        # å®Œæ•´å¯¹è¯è®°å½•
        if include_conversation:
            parts.append(self._get_template("section_conversation"))
            for msg in messages:
                parts.append(self._format_message(msg))

        # é¡µè„š
        export_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        parts.append(self._get_template("footer").format(export_time=export_time))

        return "".join(parts)

    def _generate_output_path(self, session_info: Dict[str, Any]) -> str:
        """
        ç”Ÿæˆè¾“å‡ºæ–‡ä»¶è·¯å¾„

        Args:
            session_info: ä¼šè¯ä¿¡æ¯

        Returns:
            ç”Ÿæˆçš„æ–‡ä»¶è·¯å¾„
        """
        # åˆ›å»º exports ç›®å½•
        exports_dir = Path("exports")
        exports_dir.mkdir(exist_ok=True)

        # ç”Ÿæˆæ–‡ä»¶å
        title = session_info.get("title", "planning")
        # æ¸…ç†æ ‡é¢˜ä¸­çš„éžæ³•å­—ç¬¦
        safe_title = "".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).strip()
        safe_title = safe_title.replace(' ', '_')[:50]  # é™åˆ¶é•¿åº¦

        # æ·»åŠ æ—¶é—´æˆ³
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{safe_title}_{timestamp}.md"

        return str(exports_dir / filename)

    def export_planning_only(
        self,
        session_id: Optional[str] = None,
        output_path: Optional[str] = None
    ) -> str:
        """
        ä»…å¯¼å‡ºè§„åˆ’å†…å®¹ï¼ˆä¸åŒ…å«å®Œæ•´å¯¹è¯ï¼‰

        Args:
            session_id: ä¼šè¯ID
            output_path: è¾“å‡ºè·¯å¾„ï¼Œå¦‚æžœä¸ºNoneåˆ™è‡ªåŠ¨ç”Ÿæˆ

        Returns:
            å¯¼å‡ºçš„æ–‡ä»¶è·¯å¾„
        """
        return self.export_session_to_markdown(
            session_id=session_id,
            output_path=output_path,
            include_conversation=False
        )

    def get_markdown_preview(
        self,
        session_id: Optional[str] = None,
        max_length: int = 500
    ) -> str:
        """
        èŽ·å– Markdown é¢„è§ˆï¼ˆä¸ä¿å­˜æ–‡ä»¶ï¼‰

        Args:
            session_id: ä¼šè¯ID
            max_length: æœ€å¤§é¢„è§ˆé•¿åº¦

        Returns:
            Markdown é¢„è§ˆæ–‡æœ¬
        """
        if session_id is None:
            session_id = self.session_manager.current_session_id
            if not session_id:
                return "No active session"

        session_info = self.dao.get_session(session_id)
        if not session_info:
            return f"Session not found: {session_id}"

        context = self.session_manager.build_agent_context(session_id)
        if not context:
            return "Failed to build context"

        md_content = self._build_markdown_content(
            session_info=session_info,
            messages=context.dialogue_history,
            include_conversation=False
        )

        if len(md_content) > max_length:
            return md_content[:max_length] + "\n\n... (truncated)"

        return md_content
