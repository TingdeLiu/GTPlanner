"""
规划结果导出工具

用于将 GTPlanner 的对话历史和规划结果导出为结构化的 Markdown 文件。
支持多语言输出和自定义模板。
"""

import os
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Dict, Any
from ..context_types import Message, MessageRole
from ..persistence.sqlite_session_manager import SQLiteSessionManager
from ..persistence.database_dao import DatabaseDAO


class PlannerExporter:
    """规划结果导出器"""

    # Markdown 模板 - 多语言支持
    TEMPLATES = {
        "zh": {
            "title": "# {title}\n\n",
            "metadata": "**创建时间**: {created_at}  \n**会话ID**: {session_id}  \n**项目阶段**: {project_stage}  \n**消息数量**: {message_count}  \n\n---\n\n",
            "section_requirement": "## 📋 需求描述\n\n",
            "section_planning": "## 🎯 规划方案\n\n",
            "section_conversation": "## 💬 完整对话记录\n\n",
            "user_message": "### 👤 用户\n\n{content}\n\n",
            "assistant_message": "### 🤖 助手\n\n{content}\n\n",
            "tool_message": "### 🔧 工具执行: {tool_name}\n\n```json\n{content}\n```\n\n",
            "footer": "\n---\n\n*此文档由 GTPlanner 自动生成于 {export_time}*\n",
            "no_planning": "*暂无明确的规划内容*"
        },
        "en": {
            "title": "# {title}\n\n",
            "metadata": "**Created**: {created_at}  \n**Session ID**: {session_id}  \n**Project Stage**: {project_stage}  \n**Messages**: {message_count}  \n\n---\n\n",
            "section_requirement": "## 📋 Requirements\n\n",
            "section_planning": "## 🎯 Planning\n\n",
            "section_conversation": "## 💬 Conversation History\n\n",
            "user_message": "### 👤 User\n\n{content}\n\n",
            "assistant_message": "### 🤖 Assistant\n\n{content}\n\n",
            "tool_message": "### 🔧 Tool Execution: {tool_name}\n\n```json\n{content}\n```\n\n",
            "footer": "\n---\n\n*Generated by GTPlanner at {export_time}*\n",
            "no_planning": "*No explicit planning content found*"
        },
        "ja": {
            "title": "# {title}\n\n",
            "metadata": "**作成日時**: {created_at}  \n**セッションID**: {session_id}  \n**プロジェクト段階**: {project_stage}  \n**メッセージ数**: {message_count}  \n\n---\n\n",
            "section_requirement": "## 📋 要件説明\n\n",
            "section_planning": "## 🎯 計画案\n\n",
            "section_conversation": "## 💬 会話履歴\n\n",
            "user_message": "### 👤 ユーザー\n\n{content}\n\n",
            "assistant_message": "### 🤖 アシスタント\n\n{content}\n\n",
            "tool_message": "### 🔧 ツール実行: {tool_name}\n\n```json\n{content}\n```\n\n",
            "footer": "\n---\n\n*このドキュメントは {export_time} に GTPlanner によって自動生成されました*\n",
            "no_planning": "*明確な計画内容が見つかりませんでした*"
        },
        "es": {
            "title": "# {title}\n\n",
            "metadata": "**Creado**: {created_at}  \n**ID de Sesión**: {session_id}  \n**Etapa del Proyecto**: {project_stage}  \n**Mensajes**: {message_count}  \n\n---\n\n",
            "section_requirement": "## 📋 Requisitos\n\n",
            "section_planning": "## 🎯 Planificación\n\n",
            "section_conversation": "## 💬 Historial de Conversación\n\n",
            "user_message": "### 👤 Usuario\n\n{content}\n\n",
            "assistant_message": "### 🤖 Asistente\n\n{content}\n\n",
            "tool_message": "### 🔧 Ejecución de Herramienta: {tool_name}\n\n```json\n{content}\n```\n\n",
            "footer": "\n---\n\n*Generado por GTPlanner el {export_time}*\n",
            "no_planning": "*No se encontró contenido de planificación explícito*"
        },
        "fr": {
            "title": "# {title}\n\n",
            "metadata": "**Créé**: {created_at}  \n**ID de Session**: {session_id}  \n**Étape du Projet**: {project_stage}  \n**Messages**: {message_count}  \n\n---\n\n",
            "section_requirement": "## 📋 Exigences\n\n",
            "section_planning": "## 🎯 Planification\n\n",
            "section_conversation": "## 💬 Historique de Conversation\n\n",
            "user_message": "### 👤 Utilisateur\n\n{content}\n\n",
            "assistant_message": "### 🤖 Assistant\n\n{content}\n\n",
            "tool_message": "### 🔧 Exécution d'Outil: {tool_name}\n\n```json\n{content}\n```\n\n",
            "footer": "\n---\n\n*Généré par GTPlanner le {export_time}*\n",
            "no_planning": "*Aucun contenu de planification explicite trouvé*"
        }
    }

    def __init__(self, session_manager: Optional[SQLiteSessionManager] = None, language: str = "zh"):
        """
        初始化导出器

        Args:
            session_manager: 会话管理器实例，如果为None则创建新实例
            language: 输出语言 (zh/en/ja/es/fr)
        """
        self.session_manager = session_manager or SQLiteSessionManager()
        self.dao = DatabaseDAO()
        self.language = language if language in self.TEMPLATES else "zh"

    def _get_template(self, key: str) -> str:
        """获取模板字符串"""
        return self.TEMPLATES[self.language].get(key, "")

    def _extract_planning_content(self, messages: List[Message]) -> str:
        """
        从对话历史中提取规划相关内容

        Args:
            messages: 消息列表

        Returns:
            提取的规划内容
        """
        planning_parts = []

        for msg in messages:
            # 提取助手的规划回复
            if msg.role == MessageRole.ASSISTANT and msg.content:
                # 检查是否包含规划关键词
                if any(keyword in msg.content.lower() for keyword in
                       ['规划', '方案', '设计', 'plan', 'design', 'architecture', '流程', 'workflow']):
                    planning_parts.append(msg.content)

        return "\n\n".join(planning_parts) if planning_parts else self._get_no_planning_message()

    def _get_no_planning_message(self) -> str:
        """获取无规划内容提示"""
        return self._get_template("no_planning")

    def _format_message(self, msg: Message) -> str:
        """
        格式化单条消息

        Args:
            msg: 消息对象

        Returns:
            格式化后的 Markdown 字符串
        """
        if msg.role == MessageRole.USER:
            return self._get_template("user_message").format(content=msg.content)
        elif msg.role == MessageRole.ASSISTANT:
            return self._get_template("assistant_message").format(content=msg.content)
        elif msg.role == MessageRole.TOOL:
            # 尝试提取工具名称
            tool_name = "Unknown"
            content = msg.content

            # 如果内容是字典格式，尝试提取工具名称
            if isinstance(msg.content, str) and msg.content.startswith("{"):
                import json
                try:
                    data = json.loads(msg.content)
                    tool_name = data.get("tool_name", tool_name)
                    content = json.dumps(data, indent=2, ensure_ascii=False)
                except:
                    pass

            return self._get_template("tool_message").format(
                tool_name=tool_name,
                content=content
            )
        else:
            return f"**{msg.role.value}**: {msg.content}\n\n"

    def export_session_to_markdown(
        self,
        session_id: Optional[str] = None,
        output_path: Optional[str] = None,
        include_conversation: bool = True,
        auto_filename: bool = True
    ) -> str:
        """
        导出会话到 Markdown 文件

        Args:
            session_id: 会话ID，如果为None则使用当前会话
            output_path: 输出文件路径，如果为None则使用自动生成的路径
            include_conversation: 是否包含完整对话历史
            auto_filename: 是否自动生成文件名（已废弃，由output_path是否为None决定）

        Returns:
            导出的文件路径

        Raises:
            ValueError: 当没有可用的会话时
        """
        # 确定会话ID
        if session_id is None:
            session_id = self.session_manager.current_session_id
            if not session_id:
                raise ValueError("No active session. Please specify a session_id or create a new session.")

        # 获取会话信息
        session_info = self.dao.get_session(session_id)
        if not session_info:
            raise ValueError(f"Session not found: {session_id}")

        # 获取对话历史
        context = self.session_manager.build_agent_context(session_id)
        if not context:
            raise ValueError(f"Failed to build context for session: {session_id}")

        # 构建 Markdown 内容
        md_content = self._build_markdown_content(
            session_info=session_info,
            messages=context.dialogue_history,
            include_conversation=include_conversation
        )

        # 确定输出路径
        # 如果用户没有提供路径，使用默认文件名 Plan.md（保存到当前路径）
        if output_path is None:
            output_path = "Plan.md"
        # 用户提供了路径，直接使用（相对路径或绝对路径）

        # 确保输出目录存在
        output_dir = os.path.dirname(output_path)
        if output_dir:
            os.makedirs(output_dir, exist_ok=True)

        # 写入文件
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(md_content)

        return output_path

    def _build_markdown_content(
        self,
        session_info: Dict[str, Any],
        messages: List[Message],
        include_conversation: bool
    ) -> str:
        """
        构建 Markdown 内容

        Args:
            session_info: 会话信息
            messages: 消息列表
            include_conversation: 是否包含完整对话

        Returns:
            完整的 Markdown 内容
        """
        parts = []

        # 标题
        title = session_info.get("title", "Untitled Planning")
        parts.append(self._get_template("title").format(title=title))

        # 元数据
        parts.append(self._get_template("metadata").format(
            created_at=session_info.get("created_at", "Unknown"),
            session_id=session_info.get("session_id", "Unknown")[:12] + "...",
            project_stage=session_info.get("project_stage", "Unknown"),
            message_count=len(messages)
        ))

        # 需求描述（第一条用户消息）
        user_messages = [msg for msg in messages if msg.role == MessageRole.USER]
        if user_messages:
            parts.append(self._get_template("section_requirement"))
            parts.append(user_messages[0].content + "\n\n")

        # 规划方案（提取的规划内容）
        parts.append(self._get_template("section_planning"))
        planning_content = self._extract_planning_content(messages)
        parts.append(planning_content + "\n\n")

        # 完整对话记录
        if include_conversation:
            parts.append(self._get_template("section_conversation"))
            for msg in messages:
                parts.append(self._format_message(msg))

        # 页脚
        export_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        parts.append(self._get_template("footer").format(export_time=export_time))

        return "".join(parts)

    def _generate_output_path(self, session_info: Dict[str, Any]) -> str:
        """
        生成输出文件路径

        Args:
            session_info: 会话信息

        Returns:
            生成的文件路径
        """
        # 创建 exports 目录
        exports_dir = Path("exports")
        exports_dir.mkdir(exist_ok=True)

        # 生成文件名
        title = session_info.get("title", "planning")
        # 清理标题中的非法字符
        safe_title = "".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).strip()
        safe_title = safe_title.replace(' ', '_')[:50]  # 限制长度

        # 添加时间戳
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{safe_title}_{timestamp}.md"

        return str(exports_dir / filename)

    def export_planning_only(
        self,
        session_id: Optional[str] = None,
        output_path: Optional[str] = None
    ) -> str:
        """
        仅导出规划内容（不包含完整对话）

        Args:
            session_id: 会话ID
            output_path: 输出路径，如果为None则自动生成

        Returns:
            导出的文件路径
        """
        return self.export_session_to_markdown(
            session_id=session_id,
            output_path=output_path,
            include_conversation=False
        )

    def get_markdown_preview(
        self,
        session_id: Optional[str] = None,
        max_length: int = 500
    ) -> str:
        """
        获取 Markdown 预览（不保存文件）

        Args:
            session_id: 会话ID
            max_length: 最大预览长度

        Returns:
            Markdown 预览文本
        """
        if session_id is None:
            session_id = self.session_manager.current_session_id
            if not session_id:
                return "No active session"

        session_info = self.dao.get_session(session_id)
        if not session_info:
            return f"Session not found: {session_id}"

        context = self.session_manager.build_agent_context(session_id)
        if not context:
            return "Failed to build context"

        md_content = self._build_markdown_content(
            session_info=session_info,
            messages=context.dialogue_history,
            include_conversation=False
        )

        if len(md_content) > max_length:
            return md_content[:max_length] + "\n\n... (truncated)"

        return md_content
